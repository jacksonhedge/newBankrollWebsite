var q=Object.defineProperty;var $=(s,e,t)=>e in s?q(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var G=(s,e,t)=>$(s,typeof e!="symbol"?e+"":e,t);import{d as g,D as m,E as b,A as y,J as I,K as A,M as C,N as L,O as x,Q as P,a as U,q as R,w as B,g as S,S as j}from"./index-CEC4yryL-1733463724861.js";const w=[];for(let s=0;s<256;++s)w.push((s+256).toString(16).slice(1));function F(s,e=0){return(w[s[e+0]]+w[s[e+1]]+w[s[e+2]]+w[s[e+3]]+"-"+w[s[e+4]]+w[s[e+5]]+"-"+w[s[e+6]]+w[s[e+7]]+"-"+w[s[e+8]]+w[s[e+9]]+"-"+w[s[e+10]]+w[s[e+11]]+w[s[e+12]]+w[s[e+13]]+w[s[e+14]]+w[s[e+15]]).toLowerCase()}let D;const H=new Uint8Array(16);function T(){if(!D){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");D=crypto.getRandomValues.bind(crypto)}return D(H)}const O=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),W={randomUUID:O};function N(s,e,t){if(W.randomUUID&&!e&&!s)return W.randomUUID();s=s||{};const r=s.random||(s.rng||T)();return r[6]=r[6]&15|64,r[8]=r[8]&63|128,F(r)}const M=g;if(!M)throw new Error("Firestore must be initialized");class V{constructor(){G(this,"db");this.db=M}async createGroupWallet(e,t){const r={platformId:`group_${e}`,groupId:e,ownerId:t,name:"Group Wallet",logo:"/images/BankrollLogoTransparent.png",cashBalance:0,bonusBalances:[],totalBonusBalance:0,lastUpdated:new Date,status:"active",connected:!0,memberBalances:{},expenses:[]},n=m(this.db,"groups",e);return await b(n,{wallet:r}),await this.addGroupWalletToUser(t,r),r}async addGroupWalletToUser(e,t){const r=m(this.db,"users",e),a=(await y(r)).data();if(a!=null&&a.wallet){const l=a.wallet;l.subWallets[t.platformId]=t,await b(r,{"wallet.subWallets":l.subWallets})}}async getGroupWallet(e){const t=m(this.db,"groups",e),n=(await y(t)).data();return(n==null?void 0:n.wallet)||null}async addFunds(e,t,r){await I(this.db,async n=>{const a=m(this.db,"groups",e),o=(await n.get(a)).data();if(!(o!=null&&o.wallet))throw new Error("Group wallet not found");const c=o.wallet;c.cashBalance+=t,c.lastUpdated=new Date,c.memberBalances[r]=(c.memberBalances[r]||0)+t,n.update(a,{wallet:c});const u={id:crypto.randomUUID(),walletId:e,platformId:c.platformId,type:"deposit",amount:t,timestamp:new Date,status:"completed",metadata:{userId:r,description:"Group wallet deposit"}};n.set(m(this.db,"wallet_transactions",u.id),u)})}async addExpense(e,t,r,n,a){await I(this.db,async l=>{const o=m(this.db,"groups",e),u=(await l.get(o)).data();if(!(u!=null&&u.wallet))throw new Error("Group wallet not found");const d=u.wallet,i={id:crypto.randomUUID(),description:t,amount:r,paidBy:n,splitBetween:a,timestamp:new Date,status:"completed"};d.expenses.push(i);const f=r/a.length;a.forEach(p=>{p!==n&&(d.memberBalances[p]=(d.memberBalances[p]||0)-f)}),d.memberBalances[n]=(d.memberBalances[n]||0)+r,l.update(o,{wallet:d});const h={id:crypto.randomUUID(),walletId:e,platformId:d.platformId,type:"group_expense",amount:r,timestamp:new Date,status:"completed",metadata:{expenseId:i.id,paidBy:n,splitBetween:a,description:t}};l.set(m(this.db,"wallet_transactions",h.id),h)})}async getMemberBalance(e,t){const r=await this.getGroupWallet(e);if(!r)throw new Error("Group wallet not found");return r.memberBalances[t]||0}async getExpenses(e){const t=await this.getGroupWallet(e);if(!t)throw new Error("Group wallet not found");return t.expenses}}const z=new V;class v{constructor(){if(v.instance)return v.instance;v.instance=this,this.auth=A(C),this.functions=L(C)}async sendGroupInvite(e,t,r){try{if(!e||!t||!r)throw new Error("Missing required parameters for group invite");if(!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(r))throw new Error("Invalid email format");if(!this.auth.currentUser)throw new Error("User must be authenticated");const a=x(this.functions,"sendGroupInvite");console.log("Sending invite to:",{groupId:e,groupName:t,toEmail:r});const l=await a({groupId:e,groupName:t,toEmail:r.trim().toLowerCase()});return console.log("Email send result:",l),l.data}catch(n){throw console.error("Error sending invite email:",n),n.code==="unauthenticated"?new Error("Please sign in to send invites"):n.code==="internal"?new Error("Unable to send invite at this time. Please try again later."):n}}async sendBulkGroupInvites(e,t,r){try{if(!e||!t||!Array.isArray(r))throw new Error("Invalid parameters for bulk invites");const n=/^[^\s@]+@[^\s@]+\.[^\s@]+$/,a=r.map(c=>c.trim().toLowerCase()).filter(c=>n.test(c));if(a.length===0)throw new Error("No valid emails provided");if(!this.auth.currentUser)throw new Error("User must be authenticated");const l=x(this.functions,"sendBulkGroupInvites");console.log("Sending bulk invites:",{groupId:e,groupName:t,emailCount:a.length,emails:a});const o=await l({groupId:e,groupName:t,emails:a});if(console.log("Bulk invite result:",o.data),!o.data.success)throw new Error("Failed to send invites");return{success:!0,sentCount:o.data.sentCount,failedCount:o.data.failedCount,results:o.data.results}}catch(n){throw console.error("Error sending bulk invite emails:",n),n.code==="unauthenticated"?new Error("Please sign in to send invites"):n.code==="internal"?new Error("Unable to send invites at this time. Please try again later."):n}}}const J=new v;class E{constructor(){if(E.instance)return E.instance;E.instance=this,this.groupsCollection="groups",this.usersCollection="users",this.baseUrl="https://bankroll.live"}generateGroupUrl(e){return`${this.baseUrl}/groups/${e}`}async deleteGroup(e){try{if(!e)throw new Error("Group ID is required");const t=m(g,this.groupsCollection,e);if(!(await y(t)).exists())throw new Error("Group not found");return await P(t),!0}catch(t){throw console.error("Error deleting group:",t),t}}async inviteUsers(e,t){try{if(!e||!t||!t.length)throw new Error("Group ID and at least one email are required");const r=m(g,this.groupsCollection,e),n=await y(r);if(!n.exists())throw new Error("Group not found");const a=n.data(),l=[],o=new Set([...(a.members||[]).map(i=>i.email||""),...(a.pendingMembers||[]).map(i=>i.identifier||"")].filter(Boolean)),c=t.filter(i=>!o.has(i));if(c.length===0)throw new Error("All emails are already invited or members");console.log("Sending invites to:",c);const u=await J.sendBulkGroupInvites(e,a.name,c);if(console.log("Email sending results:",u),!u.success)throw new Error("Failed to send invites");const d=u.results.filter(i=>i.success).map(i=>i.email);d.forEach(i=>{l.push({identifier:i,type:"email",status:"pending",invitedAt:new Date().toISOString()})}),await b(r,{pendingMembers:[...a.pendingMembers||[],...l]});try{const i=U(g,this.usersCollection),f=R(i,B("email","in",d)),h=await S(f);h.empty||h.docs.forEach(p=>{console.log(`Should send notification to user ${p.id} about group invite`)})}catch(i){console.warn("Failed to send notifications:",i)}return{success:!0,message:`Successfully sent ${d.length} invites`,invitedCount:d.length,skippedCount:t.length-d.length}}catch(r){throw console.error("Error inviting users:",r),r}}sanitizeUserData(e){return{uid:e.uid||"",displayName:e.displayName||"",username:e.username||"",phone:e.phone||"",photoURL:e.photoURL||null,firstName:e.firstName||"",lastName:e.lastName||""}}createInitialWallet(e,t){return{platformId:`group_${e}`,groupId:e,ownerId:t,name:"Group Wallet",logo:"/images/BankrollLogoTransparent.png",cashBalance:0,bonusBalances:[],totalBonusBalance:0,lastUpdated:new Date,status:"active",connected:!0,memberBalances:{},expenses:[]}}async getUserGroups(e){try{if(!e)throw new Error("User ID is required");const t=U(g,this.groupsCollection),r=R(t,B("memberIds","array-contains",e)),n=await S(r),a=[];for(const l of n.docs){const o=l.data(),c=await this.getUserData(o.ownerId),u=(o.memberIds||[]).map(async p=>{try{return await this.getUserData(p)}catch(k){return console.error(`Error fetching member data for ${p}:`,k),null}}),i=(await Promise.all(u)).filter(p=>p!==null),f=Array.from(new Map(i.map(p=>[p.uid,p])).values());let h=o.wallet;h||(h=this.createInitialWallet(l.id,o.ownerId),await b(l.ref,{wallet:h})),a.push({id:l.id,name:o.name||"",description:o.description||"",emoji:o.emoji||"ðŸ‘¥",ownerId:o.ownerId,owner:c,members:f,memberIds:o.memberIds||[],pendingMembers:o.pendingMembers||[],dateCreated:o.dateCreated||new Date().toISOString(),isHidden:o.isHidden||!1,visibility:o.visibility||"private",inviteLink:this.generateGroupUrl(l.id),status:o.status||"active",wallet:h})}return a}catch(t){throw console.error("Error fetching user groups:",t),t}}async getUserData(e){try{const t=m(g,this.usersCollection,e),r=await y(t);return r.exists()?{uid:e,...r.data()}:null}catch(t){throw console.error("Error fetching user data:",t),t}}async createGroup(e,t){try{if(console.log("Creating group with data:",{groupData:e,creator:t}),!e||!t)throw new Error("Group data and creator information are required");if(!e.name)throw new Error("Group name is required");if(!t.id&&!t.uid)throw new Error("Creator must have an id or uid property");const r=t.id||t.uid,n=N(),a=U(g,this.groupsCollection),l=await this.getUserData(r);console.log("Creator data:",l);const o=this.createInitialWallet(n,r),c={id:n,name:e.name,emoji:e.emoji||"ðŸ‘¥",description:e.description||"",ownerId:r,owner:l,members:[l],memberIds:[r],pendingMembers:[],dateCreated:new Date().toISOString(),isHidden:!1,visibility:e.visibility||"private",inviteLink:this.generateGroupUrl(n),status:"active",wallet:o};console.log("Creating new group:",c);const u=await j(a,c);return console.log("Group created with ID:",u.id),await b(u,{id:u.id}),await z.createGroupWallet(u.id,r),{...c,id:u.id}}catch(r){throw console.error("Error creating group:",r),r}}async getGroup(e){try{if(!e)throw new Error("Group ID is required");const t=m(g,this.groupsCollection,e),r=await y(t);if(r.exists()){const n=r.data(),a=await this.getUserData(n.ownerId),l=(n.memberIds||[]).map(async i=>{try{return await this.getUserData(i)}catch(f){return console.error(`Error fetching member data for ${i}:`,f),null}}),c=(await Promise.all(l)).filter(i=>i!==null),u=Array.from(new Map(c.map(i=>[i.uid,i])).values());let d=n.wallet;return d||(d=this.createInitialWallet(e,n.ownerId),await b(t,{wallet:d})),{id:r.id,name:n.name||"",description:n.description||"",emoji:n.emoji||"ðŸ‘¥",ownerId:n.ownerId,owner:a,members:u,memberIds:n.memberIds||[],pendingMembers:n.pendingMembers||[],dateCreated:n.dateCreated||new Date().toISOString(),isHidden:n.isHidden||!1,visibility:n.visibility||"private",inviteLink:this.generateGroupUrl(r.id),status:n.status||"active",wallet:d}}else throw new Error("Group not found")}catch(t){throw console.error("Error fetching group:",t),t}}async updateGroup(e,t){try{if(!e)throw new Error("Group ID is required");const r=m(g,this.groupsCollection,e);if(!(await y(r)).exists())throw new Error("Group not found");return await b(r,t),await this.getGroup(e)}catch(r){throw console.error("Error updating group:",r),r}}}const X=new E;export{z as a,J as e,X as g};
